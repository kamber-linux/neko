#!/bin/sh

# Disable certain shellcheck checks
# We follow non-constant sources - templates
# shellcheck disable=SC1090
# We constantly use non-constant sources by design
# shellcheck disable=SC1091
# We define FILES_DIR for use in templates
# shellcheck disable=SC2034
# We depend on vars from templates not defined here
# shellcheck disable=SC2154
# We know what we are doing with A && B || C
# shellcheck disable=SC2015

# exit codes
# 0 - successful
# 1 - invalid / unkown unput
# 2 - user exit
# 3 - missing / not found
# 4 - command fail

CURRENT_DIR=$(pwd)

# Initialize bool warning flags to false
PKGNAME_UNSET_WARNING=false
SHORT_DESC_UNSET_WARNING=false
REVISION_UNSET_WARNING=false
LICENSE_UNSET_WARNING=false
LICENSE_FILE_UNSET_WARNING=false
LICENSE_INVALID_WARNING=false
LICENSE_INSTALL_FAIL_WARNING=false

# e.g.:
# msg normal "My message"
# prints "My message" in neko message format
# msg error "Package not found" 3
# errors out "Package not found" and exit with code 3
msg()
{
	case $1 in
		normal) printf "%s\n" "[1m=> [36mneko[0m: $2" ;;
		success) printf "%s\n" "[1m=> [32mneko[0m: $2" ;;
		error) printf "%s\n" "[1m=> [31mneko[0m: $2"; exit "$3" ;;
		warning) printf "%s\n" "[1m=> [33mneko[0m: $2" ;;
		prompt) printf "%s %s " "[1m=> [35mneko[0m: $2" "[y/n]" ;;
	esac
}

# handle flags / switches
SKIP=false
HELP=false
USAGE=false
INSTALL_DIR=
REPO=
VARIABLE=
VALUE=
args=
while [ $# -gt 0 ]
do
	case $1 in
		-[Yy] | --[Yy]es)
			VARIABLE=SKIP
			VALUE=true
			shift
			;;
		-[Hh] | --[Hh]elp)
			VARIABLE=HELP
			VALUE=true
			shift
			;;
		--[Rr]epo | --[Rr]epository)
			[ $# -lt 2 ] && msg error "Missing value for ${1#--}" 3
			VARIABLE=REPO
			VALUE=$2
			shift 2
			;;
		--[Rr]epo?=* | --[Rr]epository)
			VARIABLE=REPO
			VALUE=${1#*=}
			shift
			;;
		--[Ii]nstall-[Dd]irectory | --[Ii]nstall-[Dd]ir | --[Ii]nstall[Dd]ir |\
			--[Ii]nstall[Dd]irectory)
			[ $# -lt 2 ] && msg error "Missing value for ${1#--}" 3
			VARIABLE=INSTALL_DIR
			VALUE=$2
			shift 2
			;;
		--[Ii]nstall-[Dd]irectory=* | --[Ii]nstall-[Dd]ir=* | --[Ii]nstall[Dd]ir=* |\
			--[Ii]nstall[Dd]irectory)
			VARIABLE=INSTALL_DIR
			VALUE=${1#*=}
			shift
			;;
		--[Uu]sage | -[Uu])
			VARIABLE=USAGE
			VALUE=true
			shift
			;;
		--)
			shift
			break
			;;
		-*)
			msg error "Unknown option: $1" 1
			;;
		*)
			VARIABLE=args
			VALUE="$args $1"
			shift
			;;
	esac
	eval "$VARIABLE"='"$VALUE"'
done
eval set -- "$args" '"$@"'

trap interrupt 2
interrupt()
{
	# To have new line
	echo
	msg error "Command interrupted" 2
}

usage()
{
	case $1 in
		neko)
			cat << _EOF
[1musage[0m
$0 COMMAND [TARGET]

See $0 --help
_EOF
			;;
		help)
			cat << _EOF
[1musage[0m
$0 help COMMAND

See $0 help --help
_EOF
			;;
		pkg)
			cat << _EOF
[1musage[0m
$0 pkg PKG
$0 package PKG

See $0 pkg --help
_EOF
			;;
		emerge)
			cat << _EOF
[1musage[0m
$0 em PKG
$0 emerge PKG

See $0 emerge --help
_EOF
			;;
	esac
	exit
}

help()
{
	case $1 in
		neko)
			cat << _EOF
[1musage[0m
$0 COMMAND [TARGET]

[1mCOMMAND[0m
help COMMAND
	Shows information about a command.
	See $0 help --help for more information.

pkg PKG
package PKG
	Will download, build, and install PKG to an empty DESTDIR based off of the
	template for PKG in srcpkgs. Multiple arguments can be specified to PKG.
	See $0 pkg --help for more information.

em PKG
emerge PKG
	Will call the package step and install the packaged files to the system.
	See $0 em --help for more information.
_EOF
			;;
		help)
			cat << _EOF
[1musage[0m
$0 help COMMAND

help COMMAND
	Will show information of a command, what is does, the usage, and other
	information that may be helpful.
_EOF
			;;
		pkg | package)
			cat << _EOF
[1musage[0m
$0 pkg PKG
$0 package PKG

pkg PKG
package PKG
	Will first look for a template for PKG in srcpkgs in the order of: ./srcpkgs,
	/usr/share/neko/srcpkgs. If it finds it, then, according to the template for
	PKG, will go and fetch the source code for PKG. Then, it will extract PKG or
	change commit if it's a git package. Then, it will apply all of the patches
	for the template in that PKG patches folder. Then, it will build the package
	and install the package into the ROOT_DIR, which acts as an empty DESTDIR to
	track which files got moved.
_EOF
			;;
		em | emerge)
			cat << _EOF
[1musage[0m
$0 em PKG
$0 emerge PKG

em PKG
emerge PKG
	Will first execute $0 pkg PKG to build and log an install to an empty master
	directory. Then, using the information from that database made my $0 pkg PKG,
	will install PKG to install-dir, default / if not set.
_EOF
			;;
		clean)
			cat << _EOF
[1musage[0m
$0 clean

clean
	If running from the repo, will clean everything in ./master/root,
	./master/src, and ./master/db. If installed and running as root, will clean
	the master root and source directories of the system.
_EOF
			;;
		*)
			msg warning "Can't get help for unknown command: $1" 1
			msg normal "See $0 --help for a list of commands."
			;;
	esac
	exit
}

# Prepares environment
# Gets info from template
package_init()
{
	# Clear vars and functions
	for var in pkgname short_desc deps version commit revision distfiles giturl\
		wrksrc build_style configure_args build_args install_args CC YACC license\
		license_file
	do
		unset "$var"
	done
	for function in pre_build do_build do_install
	do
		unset -f "$function"
	done
	[ -d "$CURRENT_DIR"/srcpkgs ] &&
		{
			BASE_DIR=$CURRENT_DIR
			PKGS_DIR=$BASE_DIR/srcpkgs
			DB_DIR=$BASE_DIR/master/db
		} ||
			{
				BASE_DIR=/usr/share/neko
				PKGS_DIR=$BASE_DIR/srcpkgs
				DB_DIR=/var/db/neko
			}
	MASTER_DIR=$BASE_DIR/master
	LICENSES_DIR=$MASTER_DIR/licenses
	SRC_DIR=$MASTER_DIR/src
	ROOT_DIR=$MASTER_DIR/root
	PATCHES_DIR=$PKGS_DIR/$1/patches
	FILES_DIR=$PKGS_DIR/$1/files
	[ ! -f "$PKGS_DIR/$1"/template ] && msg error "No template found for $1" 3
	. "$PKGS_DIR/$1"/template
	[ -z "$pkgname" ] && PKGNAME_UNSET_WARNING=true
	[ -z "$short_desc" ] && SHORT_DESC_UNSET_WARNING=true
	[ -z "$revision" ] && REVISION_UNSET_WARNING=true
	[ -n "$distfiles" ] && archive=${archive:-${distfiles##*/}}
	[ -n "$distfiles" ] && wrksrc=${wrksrc:-$pkgname-$version}
	[ -n "$giturl" ] && wrksrc=${wrksrc:-$pkgname}
	for dir in $MASTER_DIR $SRC_DIR $ROOT_DIR
	do
		[ ! -d "$dir" ] && mkdir -p "$dir"
	done
}

package_fetch()
{
	cd "$SRC_DIR" || exit
	[ -n "$distfiles" ] &&
		{
			[ -f "${distfiles##*/}" ] && rm -rf "${distfiles##*/}"
			msg normal "Fetching files for $1..."
			wget "$distfiles" && msg success "Successfully fetched files for $1" ||
				msg error "Failed to fetch files for $1" 4
		}
	[ -n "$giturl" ] &&
		{
			[ -d "$wrksrc" ] && rm -rf "$wrksrc"
			msg normal "Cloning repo for $1..."
			git clone "$giturl" && msg success "Successfully cloned repo for $1" ||
				msg error "Failed to clone repo for $1" 4
		}
}

package_extract()
{
	[ -n "$distfiles" ] &&
		{
			msg normal "Extracting files for $1..."
			case ${distfiles##*.} in
				"gz" | "tgz") tar -zxf "$archive" ;;
				"bz2" | "xz") tar -xf "$archive" ;;
			esac && msg success "Successfully extracted files for $1" ||
				msg error "Failed to extract files for $1" 4
		}
	cd "$wrksrc" || exit
	[ -n "$commit" ] &&
		{
			msg normal "Switching to commit $commit..."
			git checkout "$commit" &&
			msg success "Successfully switched to commit $commit" ||
				msg error "Failed to switch to commit $commit" 4
		}
}

package_patch()
{
        [ -d "$PATCHES_DIR" ] &&
		{
			msg normal "Applying patches for $1..."
			for patch in "$PATCHES_DIR"/*.patch
			do
				[ ! -f "$patch" ] &&
					{
						msg warning "There is a patches directory but no patches"
						return
					}
				msg normal "Applying patch ${patch##*/}..."
				patch -Np1 < "$patch" &&
					msg success "Successfully applied patch ${patch##*/}" ||
						msg error "Failed to apply patch $patch" 4
			done &&
				msg success "Successfully applied patches to $1"
        	}
}

# shellcheck disable=SC2086
# disable shellcheck SC2086 here as splitting is ok in this case
# same with package_install
package_build()
{
	msg normal "Building $1..."
	export CC=${CC:-tcc}
	export YACC=${YACC:-byacc}
	[ -n "$(command -v pre_build)" ] &&
		{
			pre_build || msg error "Failed to build $1" 4
		}
	[ -n "$(command -v do_build)" ] &&
		{
			do_build &&
				{
					msg success "Successfully built $1"
					return
				} || msg error "Failed to build $1" 4
		}

	case $build_style in
		meta)
			:
			;;
		makefile)
			bmake CC="$CC" YACC="$YACC" $build_args
			;;
		configure)
			./configure --prefix=/usr $configure_args
			bmake CC="$CC" YACC="$YACC" $build_args
			;;
		gnu-makefile)
			make CC="$CC" YACC="$YACC" $build_args
			;;
		gnu-configure)
			./configure --prefix=/usr $configure_args
			make CC="$CC" YACC="$YACC" $build_args
			;;
		meson)
			export CC=gcc # meson can only build with gcc
			meson --prefix=/usr build
			ninja -C build
			;;
		haskell-stack)
			stack $build_args --system-ghc --skip-ghc-check build
			;;
		*)
			msg error "No build_style or do_build" 3
			;;
	esac && msg success "Successfully built $1" ||
		msg error "Failed to build $1" 4
}

# Used in templates
# Needs to be defined before package_install if a template uses it
pkg_install()
{
	case $1 in
		file)
			# pkg_install file 755 BINARY "$PREFIX"/bin
			mkdir -p "$DESTDIR$4"
			cp -R "$3" "$DESTDIR$4"
			chmod "$2" "$DESTDIR$4/$(basename "$3")"
			;;
		bin)
			# pkg_install bin a.out awk
			[ -n "$3" ] &&
				{
					mv "$2" "$3"
					set -- "$1" "$3"
				}
			pkg_install file 755 "$2" "$PREFIX"/bin
			;;
		man)
			# pkg_install man MANPAGE.1 (NUMBER)
			pkg_install file 644 "$2" "$PREFIX/share/man/man${3:-${2##*.}}"
			;;
		inc)
			# pkg_install inc header.h
			pkg_install file "$2" "$PREFIX"/include 644
			;;
		doc)
			# pkg_install doc DOC.txt
			pkg_install 644 file "$2" "$PREFIX"/share/doc
			;;
		conf)
			# pkg_install conf dot.mkshrc /skel .mkshrc
			[ -n "$4" ] &&
				{
					mv "$2" "$4"
					set -- "$1" "$4"
				}
			pkg_install 644 file "$2" /etc"$3"
			;;
	esac
}

# shellcheck disable=SC2086
package_install()
{
	msg normal "Installing $1..."
	DESTDIR=$ROOT_DIR
	PREFIX=/usr
	[ -n "$(command -v do_install)" ] &&
		{
			do_install &&
				{
					msg success "Successfully installed $1"
					return
				} || msg error "Failed to install $1" 4
		}

	case $build_style in
		configure | makefile)
			bmake DESTDIR="$DESTDIR" PREFIX="$PREFIX" $install_args install
			;;
		gnu-configure | gnu-makefile)
			make DESTDIR="$DESTDIR" PREFIX="$PREFIX" $install_args install
			;;
		meson)
			DESTDIR="$DESTDIR" ninja -C build install
			;;
		haskell-stack)
			stack --local-bin-path="$DESTDIR"/usr/bin ${install_args} install
			;;
	esac && msg success "Successfully installed $1" ||
		msg error "Failed to install $1" 4
}

package_license()
{
	[ -z "$license" ] &&
		{
			LICENSE_UNSET_WARNING=true
			return
		}
	mkdir -p "$DESTDIR$PREFIX/share/licenses/$pkgname"
	for pkg_license in $license
	do
		case $pkg_license in
			MIT | BSD-3-Clause | ISC | custom)
				[ -z "$license_file" ] && LICENSE_FILE_UNSET_WARNING=true
				mkdir -p "$DESTDIR$PREFIX/share/licenses/$pkgname"
				for licenses in $license_file
				do
					cp -R "$licenses" "$DESTDIR$PREFIX/share/licenses/$pkgname"
					chmod 644 \
						"$DESTDIR$PREFIX/share/licenses/$pkgname/$(basename "$licenses")"
				done
				;;
			Public-Domain)
				cp -R "$LICENSES_DIR"/UNLICENSE "$DESTDIR$PREFIX"/share/licenses
				ln -sf "$DESTDIR$PREFIX"/share/licenses/UNLICENSE\
					"$DESTDIR$PREFIX/share/licenses/$pkgname/$pkg_license"
				chmod 644 "${DESTDIR}${PREFIX}"/share/licenses/UNLICENSE
				;;
			GPL-1.0-only | GPL-1.0-or-later)
				cp -R "$LICENSES_DIR"/GPL-1 "$DESTDIR$PREFIX"/share/licenses
				ln -sf "$DESTDIR$PREFIX"/share/licenses/GPL-1\
					"$DESTDIR$PREFIX/share/licenses/$pkgname/$pkg_license"
				chmod 644 "$DESTDIR$PREFIX"/share/licenses/GPL-1
				;;
			GPL-2.0-only | GPL-2.0-or-later)
				cp -R "$LICENSES_DIR"/GPL-2 "$DESTDIR$PREFIX"/share/licenses
				ln -sf "$DESTDIR$PREFIX"/share/licenses/GPL-2\
					"$DESTDIR$PREFIX/share/licenses/$pkgname/$pkg_license"
				chmod 644 "$DESTDIR$PREFIX"/share/licenses/GPL-2
				;;
			GPL-3.0-only | GPL-3.0-or-later)
				cp -R "$LICENSES_DIR"/GPL-3 "$DESTDIR$PREFIX"/share/licenses
				ln -sf "$DESTDIR$PREFIX"/share/licenses/GPL-3\
					"$DESTDIR$PREFIX/share/licenses/$pkgname/$pkg_license"
				chmod 644 "$DESTDIR$PREFIX"/share/licenses/GPL-3
				;;
			LGPL-2.0-only | LGPL-2.0-or-later)
				cp -R "$LICENSES_DIR"/LGPL-2 "$DESTDIR$PREFIX"/share/licenses
				ln -sf "$DESTDIR$PREFIX"/share/licenses/LGPL-2\
					"$DESTDIR$PREFIX/share/licenses/$pkgname/$pkg_license"
				chmod 644 "$DESTDIR$PREFIX"/share/licenses/LGPL-2
				;;
			LGPL-2.1-only | LGPL-2.1-or-later)
				cp -R "$LICENSES_DIR"/LGPL-2.1 "$DESTDIR$PREFIX"/share/licenses
				ln -sf "$DESTDIR$PREFIX"/share/licenses/LGPL-2.1\
					"$DESTDIR$PREFIX/share/licenses/$pkgname/$pkg_license"
				chmod 644 "$DESTDIR$PREFIX"/share/licenses/LGPL-2.1
				;;
			LGPL-3.0-only | LGPL-3.0-or-later)
				cp -R "$LICENSES_DIR"/LGPL-3 "$DESTDIR$PREFIX"/share/licenses
				ln -sf "$DESTDIR$PREFIX"/share/licenses/LGPL-3\
					"$DESTDIR$PREFIX/share/licenses/$pkgname/$pkg_license"
				chmod 644 "$DESTDIR$PREFIX"/share/licenses/LGPL-3
				;;
			*)
				LICENSE_INVALID_WARNING=true
				return
				;;
		esac
	done || LICENSE_INSTALL_FAIL_WARNING=true
}

[ $USAGE = true ] &&
	{
		[ $# -gt 1 ] && usage usage
		[ $# = 1 ] && usage "$1"
		[ -z "$1" ] && usage neko
	}
[ $HELP = true ] &&
	{
		[ $# -gt 1 ] && usage help
		[ $# = 1 ] && help "$1"
		[ -z "$1" ] && help neko
	}
[ -z "$1" ] && usage neko

case $1 in
	usage)
		shift
		[ $# -gt 1 ] && usage usage
		[ -z "$1" ] && usage neko
		usage "$1"
		;;
	help)
		shift
		[ $# -gt 1 ] && usage help
		[ -z "$1" ] && help neko
		help "$1"
		;;
	pkg | package)
		shift
		[ -z "$1" ] && usage pkg
		for arg
		do
			package_init "$arg"
			[ -n "$(command -v "$(printf "%s" "$arg" | sed 's/\-/\_/g'; )"_pkg)" ] &&
				{
					"$(printf "%s" "$arg" | sed 's/\-/\_/g')_pkg"
					pkgname=$arg
				}
			printf "%s\n" "PKG: $pkgname DEPS: $deps - PKG"
			for pkg_deps in $deps
			do
				$0 pkg "$pkg_deps"
			done
			for step in fetch extract patch build install license
			do
				printf "%s\n" "STEP: $step PKG: $pkgname DEPS: $deps"
				package_"$step" "$arg"
			done
			#package_fetch "$arg"
			#package_extract "$arg"
			#package_patch "$arg"
			#package_build "$arg"
			#package_install "$arg"
			#package_license "$arg"
			# FIXME
			# Need to recursively do this such that if a directory only contains empty
			# directories, this step will get rid of that, too - and so on
			# find "$ROOT_DIR" -type d |
			#	while read -r line
			#	do
			#		[ -z "$(ls "$line")" ] &&
			#			{
			#				msg warning "Removing empty directory $line..."
			#				rm -rf "$line"
			#			}
			#	done
			# FIXME
			# Still need a way to only log files from arg and not from previous packages
			# that were packaged. e.g. so that ./neko pkg st dwm does not result in the
			# package for dwm having files for dwm, all dwm deps, st, and all st deps
			# Basically, need a way to only log NEW files
			msg normal "Packaging $arg..."
			rm -rf "${DB_DIR:?}/$pkgname"
			mkdir -p "$DB_DIR/$pkgname"
			find "$ROOT_DIR" -type f,l | sed "s|$ROOT_DIR/||" |
				while read -r file
				do
					printf "%s\n" "$file $([ -f "$file" ] && cksum "$ROOT_DIR/$file" | cut -d' ' -f1)"
				done > "$DB_DIR/$pkgname/INSTALL" &&
					msg success "Successfully packaged $arg" ||
						msg error "Failed to package $arg" 4
			# Show warnings at the end
			[ $PKGNAME_UNSET_WARNING = true ] && msg warning "No pkgname set for $arg"
			[ $SHORT_DESC_UNSET_WARNING = true ] &&
				msg warning "No short_desc set for $arg"
			[ $REVISION_UNSET_WARNING = true ] && msg warning "No revision set for $arg"
			[ $LICENSE_UNSET_WARNING = true ] && msg warning "No license set for $arg"
			[ $LICENSE_FILE_UNSET_WARNING = true ] &&
				msg warning "No license_file for $license license set for $arg"
			[ $LICENSE_INVALID_WARNING = true ] &&
				msg warning "Invalid license $license set for $arg"
			[ $LICENSE_INSTALL_FAIL_WARNING = true ] &&
				msg warning "Failed to install $license license for $arg"
			cd "$CURRENT_DIR" || exit
		done
		;;
	em | emerge)
		shift
		[ -z "$1" ] && usage emerge
		for arg
		do
			package_init "$arg"
			[ $SKIP = false ] &&
				{
					msg prompt "Emerge $pkgname?"
					read -r RESPONSE
				}
			[ $SKIP = false ] && case $RESPONSE in
				[Yy] | [Yy]es)
					:
					;;
				[Nn] | [Nn]o)
					msg error "Aborting!" 2
					;;
				*)
					msg warning "Invalid response: $RESPONSE"
					msg error "Aborting!" 1
					;;
			esac
			printf "%s\n" "PKGNAME: $pkgname DEPS: $deps - EM"
			$0 pkg "$arg"
			for pkg_deps in $deps
			do
				$0 em -y --install-dir="$INSTALL_DIR" "$pkg_deps"
			done
			mkdir -p "$INSTALL_DIR"
			export DESTDIR="$INSTALL_DIR"
                        msg normal "Emerging $arg..."
                        while read -r INSTALL_LINE
                        do
                                mkdir -p\
                                        "$INSTALL_DIR/$(dirname "$(printf "%s" "$INSTALL_LINE" | cut -d' ' -f1)")"
                                cp -R "$ROOT_DIR/$(printf "%s" "$INSTALL_LINE" | cut -d' ' -f1)"\
                                        "$INSTALL_DIR/$(printf "%s" "$INSTALL_LINE" | cut -d' ' -f1)"
                        done < "$DB_DIR/$pkgname"/INSTALL &&
				msg success "Successfully emerged $arg" ||
					msg error "Failed to emerge $arg" 4
			cd "$CURRENT_DIR" || exit

		done
		;;
	find)
		for arg
		do
			FIND_DIR=
			[ -d /usr/share/neko/srcpkgs ] && FIND_DIR=/usr/share/neko/srcpkgs
			[ -d "$CURRENT_DIR"/srcpkgs ] && FIND_DIR="$CURRENT_DIR"/srcpkgs
			find "$FIND_DIR" ! -name "srcpkgs" -prune -name "*$arg*" |
				while read -r line
				do
					. "$line"/template
						printf "[1m%s[0m\t%s\n" "$pkgname" "$short_desc"
					for var in pkgname short_desc
					do
						unset "$var"
					done
				done
		done
		;;
	clean)
		[ $# -gt 1 ] && help clean
		[ "$(id -u)" = "0" ] &&
			{
				msg normal "Cleaning root dir..."
				rm -rf /usr/share/neko/master/root/* &&
					msg success "Successfully cleaned root dir" ||
						msg error "Failed to clean root dir" 4
				msg normal "Cleaning src dir..."
				rm -rf /usr/share/neko/master/src/* &&
					msg success "Successfully cleaned src dir" ||
						msg error "Failed to clean src dir" 4
				exit
			}
		
		msg normal "Cleaning root dir..."
		rm -rf "${CURRENT_DIR:?}"/master/root/* &&
				msg success "Successfully cleaned root dir" ||
					msg error "Failed to clean root dir" 4
		msg normal "Cleaning src dir..."
		rm -rf "${CURRENT_DIR:?}"/master/src/* &&
				msg success "Successfully cleaned src dir" ||
					msg error "Failed to clean src dir" 4
		msg normal "Cleaning db dir..."
		rm -rf "${CURRENT_DIR:?}"/master/db/* &&
				msg success "Successfully cleaned db dir" ||
					msg error "Failed to clean db dir" 4
		;;
	*)
		msg error "Unknown command: $1" 1
		;;
esac
exit 0
